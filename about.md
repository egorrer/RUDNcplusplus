<h1>Вычисление значения функции <em>f</em>(<em>x</em>)=0 методом половинного деления </h1>
Курсовая по курсу программирования на С++  
 -----------

<h2>Вход</h2>
<ul>
<li>функция (выбор из списка: <em>sin</em>, <em>cos</em> и т.д.)</li>
<li>две точки на оси <em>x</em></li>
<li>точность вычисления (0.1, 0.01 и т.д.)</li>
</ul>

<h2>Выход</h2>
<ul>
<li>значение x, при котором функция <em>f</em>(<em>x</em>) принимает значение, близкое к 0</li>
<li>кроме того, скрипт выдает лог вычислений</li>
</ul>

<h2>Описание алгоритма</h2>
Алгоритм предполагает, что функция монотонно возрастает/убывает, и что что при одном заданном <em>x</em> значение функции 
положительно, а при другом отрицательно. При таком условии, функция обязательно пересечет ось <em>x</em> на интервале
между правой и левой точками.  
Находим среднюю точку между заданными, проверяем, не принимает ли в ней функция значение 0.  
![Figure illustrating the method](https://github.com/egorrer/RUDNcplusplus/blob/master/image809.png "Поведение функции на отрезке")

Если нет, устанавливаем, где (на отрезке слева или справа от данной средней точки) функция будет пересекать ось <em>x</em>.  
Теперь переопределяем отрезок так, что средняя точка становится "правой" или "левой" (в зависимости от установленного выше).  
Запускаем алгоритм рекурсивно.

<strong>Алгоритм пошагово</strong>  
 -----------
0.  
а. Задаем список функций, значения которых умеет вычислять скрипт.  
б. Вводим переменную functionPointer - указатель на функцию.  

1. Пользователь вводит исходные данные  
а. Проверяем валидность введенных величин  
б. functionPointer указывает на функцию, выбранную пользователем  

2. 
а. Проверяем, что при одном заданном <em>x</em> значение функции положительно, а при другом отрицательно.  
б. Проверяем, что ни в одной из заданных точек функция еще не равна 0  

3. Запускаем функцию halfIntervalMethod  
a. Устанавливаем, какая из точек является точкой Максимума (значение функции положительно), а какая - точкой Минимума (значение функции отрицательно) 

4. Запускаем функцию searchZero  
а. Находим Cреднюю точку.  
б. Проверяем, что расстояние между правой и левой точкой еще достаточно велико (боремся с бесконечным циклом): closeEnought  
   если да, возвращаем значение Cредней точки.  
   если нет:  
в. Вычисляем значение функции в Cредней точке.  
г. Если оно положительно, то теперь Cредняя точка становится точкой Максимума,  
   если отрицательно -- то теперь Cредняя точка становится точкой Mинимума.  
   
5. Запускаем рекурсивно searchZero с новыми значениями.
